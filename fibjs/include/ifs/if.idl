/*! @mainpage My Personal Index Page
 *
 * @section intro_sec Introduction
 *
 * This is the introduction.
 *
 * @section install_sec Installation
 *
 * @subsection step1 Step 1: Opening the box
 *
 * etc...
 */

/*! @brief 基础对象，所有对象均继承于此*/
class object
{
	/*! @brief 强制回收对象，调用此方法后，对象资源将立即释放*/
	dispose();

	/*! @brief 返回对象的字符串表示，一般返回 "[Native Object]"，对象可以根据自己的特性重新实现*/
	String toString();

	/*! @brief 返回对象的 JSON 格式表示，一般返回对象定义的可读属性集合
	 * @param key
	 * @return 返回包含可 JSON 序列化的对象
	 */
	Object toJSON(String key = "");

	/*! @brief 返回对象本身 */
	Object ValueOf();
};

/*! @brief 基础模块对象，所有模块对象均继承于此*/
class module
{
};

/*! @brief 事件触发对象，可用于建立观察者模式，支持事件触发的对象均继承于此
 *
 * Event 对象可独立创建，以用于组建自定义的事件系统：
 * @code
 * var e = new Event();
 * @endcode
 */
class Event : object
{
	Event();
	on(String ev, Function func);
	once(String ev, Function func);
	off(String ev, Function func);
	trigger(String ev, ...);
};

/*! @brief 二进制数据缓存对象，用于 io 读写的数据处理
 *
 * Buffer 对象为全局基础类，在任何时候都可以直接以 new Buffer(...) 创建：
 * @code
 * var buf = new Buffer();
 * @endcode
 */
class Buffer : object
{
	/*! @brief 缓存对象构造函数
	 * @param str 初始化字符串，字符串将以 utf-8 格式写入，缺省则创建一个空对象
	 */
	Buffer(String str = "");

	/*! @brief 缓存对象可使用下标直接访问二进制数据*/
	Integer operator[];

	/*! @brief 获取缓存对象的尺寸 */
	readonly Integer length;

	/*! @brief 修改缓存对象尺寸 */
	resize(Integer sz);

	/*! @brief 向缓存对象写入字符串，字符串将以 utf-8 格式写入 */
	write(String str);

	/*! @brief 返回一个新缓存对象，包含指定范围的数据，若范围超出缓存，则只返回有效部分数据
	 * @param start 指定范围的起始，缺省从头开始
	 * @param end 指定范围的结束，缺省到缓存结尾
	 */
	Buffer slice(Integer start = 0, Integer end = -1);

	/*! @brief 以字符串形式返回缓存内的数据，字符串将以 utf-8 编码读出 */
	String toString();
};

/*! @brief 断言测试模块，如果测试值为假，则报错，报错行为可设定继续运行或者错误抛出
 *
 * 引用方法：
 * @code
 * var assert = require('assert');
 * @endcode
 */
class assert : module
{
	/*! @brief 测试数值为真，为假则断言失败
	 * @param value 要测试的数值
	 * @param msg 断言失败时的提示信息
	 */
	static ok(Boolean value, String msg = "");

	/*! @brief 测试数值等于预期值，不相等则断言失败
	 * @param actual 要测试的数值
	 * @param expected 预期的数值
	 * @param msg 断言失败时的提示信息
	 */
	static equal(Value actual, Value expected, String msg = "");

	/*! @brief 测试数值不等于预期值，相等则断言失败
	 * @param actual 要测试的数值
	 * @param expected 预期的数值
	 * @param msg 断言失败时的提示信息
	 */
	static notEqual(Value actual, Value expected, String msg = "");

	/*! @brief 测试数值严格等于预期值，不相等则断言失败
	 * @param actual 要测试的数值
	 * @param expected 预期的数值
	 * @param msg 断言失败时的提示信息
	 */
	static strictEqual(Value actual, Value expected, String msg = "");

	/*! @brief 测试数值不严格等于预期值，相等则断言失败
	 * @param actual 要测试的数值
	 * @param expected 预期的数值
	 * @param msg 断言失败时的提示信息
	 */
	static notStrictEqual(Value actual, Value expected, String msg = "");

	/*! @brief 测试给定的代码会抛出错误，未抛出则断言失败
	 * @param block 指定测试的代码，以函数形式给出
	 * @param msg 断言失败时的提示信息
	 */
	static throws(Function block, String msg = "");

	/*! @brief 测试给定的代码不会抛出错误，抛出则断言失败
	 * @param block 指定测试的代码，以函数形式给出
	 * @param msg 断言失败时的提示信息
	 */
	static doesNotThrow(Function block, String msg = "");

	/*! @brief 设定断言失败的策略，系统启动时为 false
	 * @param bThrow 为 true 时，断言失败将被抛出错误，否则只输出错误信息到警告日志
	 */
	static throwAssert(Boolean bThrow = true);
};

/*! @brief 文件路径处理模块
 *
 * 引用方法：
 * @code
 * var path = require('path');
 * @endcode
 */
class path : module
{
	/*! @brief 标准化路径，处理路径中父目录等信息
	 *
	 * @param path 给定的未处理的路径
	 * @return 返回经过处理的路径
	 */
	static String normalize(String path);

	/*! @brief 查询路径中的文件名称，若指定扩展名，则自动取消匹配的扩展名
	 *
	 * @param path 给定查询的路径
	 * @param ext 指定扩展名，若文件名中有符合条件的扩展名，将自动取消
	 * @return 返回文件名称
	 */
	static String basename(String path, String ext = "");

	/*! @brief 查询路径中的文件扩展名
	 *
	 * @param path 给定查询的路径
	 * @return 返回得到的扩展名
	 */
	static String extname(String path);

	/*! @brief 查询路径中的目录路径
	 *
	 * @param path 给定查询的路径
	 * @return 返回得到的目录的路径
	 */
	static String dirname(String path);

	/*! @brief 合并一系列路径成为一个单一路径
	 *
	 * @param ... 一个或多个相关的路径
	 * @return 返回得到的新路径
	 */
	static String combine(...);
};

/*! @brief 控制台访问对象
 *
 * 全局对象。可用于提示信息，警告和错误记录。通过启动配置文件，可将日志定位
 * 到不同的设备，以便于跟踪。日志支持格式化输出，例如：
 * @code
 * console.log("%d + %d = %d", 100, 200, 100 + 200);
 * @endcode
 * 可以使用的格式化参数如下：
 * - %s - 字符串
 * - %d - 数字，包括整数和数字
 * - %j - 以 JSON 格式输出对象
 * - %% - 输出字符 '%' 本身
 */
class console : module
{
	/*! @brief 记录普通日志信息，与 info 等同
	 *
	 * 记录一般等级的日志信息。通常用于输出非错误性提示信息。
	 * @param fmt 格式化字符串
	 * @param ... 可选参数列表
	 */
	static log(String fmt, ...);

	/*! @brief 记录普通日志信息，与 log 等同
	 *
	 * 记录一般等级的日志信息。通常用于输出非错误性提示信息。
	 * @param fmt 格式化字符串
	 * @param ... 可选参数列表
	 */
	static info(String fmt, ...);

	/*! @brief 记录警告日志信息
	 *
	 * 记录警告日志信息。通常用于输出非错误性调试信息。重要。
	 * @param fmt 格式化字符串
	 * @param ... 可选参数列表
	 */
	static warn(String fmt, ...);

	/*! @brief 记录错误日志信息
	 *
	 * 记录用于错误日志信息。通常用于输出非错误性调试信息。非常重要。系统的出错信息也会以此等级记录。
	 * @param fmt 格式化字符串
	 * @param ... 可选参数列表
	 */
	static error(String fmt, ...);

	/*! @brief 用 JSON 格式输出对象
	 * @param obj 给定要显示的对象
	 */
	static dir(Object obj);

	/*! @brief 启动一个计时器
	 *
	 * @param label 标题，缺省为空字符串。
	 */
	static time(String label = "time");

	/*! @brief 统计指定计时器的数值
	 *
	 * @param label 标题，缺省为空字符串。
	 */
	static timeEnd(String label = "time");

	/*! @brief 输出当前调用堆栈
	 *
	 * 通过日志输出当前调用堆栈。
	 * @param label 标题，缺省为空字符串。
	 */
	static trace(String label = "trace");

	/*! @brief 断言测试，如果测试值为假，则报错
	 * @param value 测试的数值
	 * @param msg 报错信息
	 */
	static assert(Boolean value, String msg = "");
};

/*! @brief 操作系统信息查询模块
 *
 * 使用方法：
 * @code
 * var os = require('os');
 * @endcode
 */
class os : module
{
	/*! @brief 查询当前运行环境主机名*/
	static String hostname();

	/*! @brief 查询当前运行环境操作系统名称*/
	static String type();

	/*! @brief 查询当前运行环境操作系统版本*/
	static String release();

	/*! @brief 查询当前运行环境*/
	static String arch();

	/*! @brief 查询当前运行环境 cpu 个数和参数*/
	static Array CPUInfo();

	/*! @brief 查询当前运行环境网络信息*/
	static Array networkInfo();
};

/*! @brief 流操作对象，用于二进制数据流读写*/
class Stream : object
{
	const Integer SEEK_SET = 0;
	const Integer SEEK_CUR = 1;
	const Integer SEEK_END = 2;

	/*! @brief 查询当前流是否允许读*/
	readonly Boolean readable;

	/*! @brief 查询当前流是否允许写*/
	readonly Boolean writable;

	/*! @brief 从流内读取指定大小的数据
	 * @param size 指定要读取的数据量，缺省为读取剩余全部数据
	 * @return 返回从流内读取的数据
	 */
	Buffer read(Integer size = -1);

	/*! @brief 将给定的数据写入流
	 * @param data 给定要写入的数据
	 */
	write(Buffer data);

	/*	Boolean readable;
	 Boolean writable;
	 setEncoding(String encoding = "utf-8");
	 String read(Integer size = 0);
	 String readln();
	 String readutil(String eos);
	 write(String str);*/
};

/*! @brief 文件的基础信息对象
 */
class Stat : object
{
	/*! @brief 文件尺寸 */
	readonly Number size;

	/*! @brief 文件最后修改时间 */
	readonly Date mtime;

	/*! @brief 文件最后访问时间 */
	readonly Date atime;

	/*! @brief 文件创建时间 */
	readonly Date ctime;
};

class File : Stream
{
	Number data;
	Number getData();

	/*	close();
	 Boolean closed();
	 flush();
	 readable();
	 String readline(Integer limit = -1);
	 Integer seek(Integer offset, Integer whence = SEEK_SET);
	 Boolean seekable();
	 Integer tell();
	 Integer truncate(Integer size = -1);
	 Boolean writeable();

	 data read(Integer size = -1);
	 data readall();
	 write(data d);*/
};

/*! @brief 文件处理模块
 *
 * 使用方法：
 * @code
 * var fs = require('fs');
 * @endcode
 */
class fs : module
{
	const Integer SEEK_SET = 0;
	const Integer SEEK_CUR = 1;
	const Integer SEEK_END = 2;

	/*! @brief 打开文件，用于读取，写入，或者同时读写
	 * @param fname 指定文件名
	 * @param mode 指定文件打开方式，缺省为 "r"，只读方式。支持的方式如下：
	 * - 'r' 只读方式，文件不存在则抛出错误。
	 * - 'r+' 读写方式，文件不存在则抛出错误。
	 * - 'w' 只写方式，文件不存在则自动创建，存在则将被清空。
	 * - 'w+' 读写方式，文件不存在则自动创建。
	 * - 'a' 只写添加方式，文件不存在则自动创建。
	 * - 'a+' 读写添加方式，文件不存在则自动创建。
	 * @return 返回打开的文件对象
	 */
	static File open(String fname, String mode = "r") async;
	static File create(String fname, Boolean Overwrite = true) async;
	static File tmpFile() async;

	/*! @brief 打开文件，并读取内容
	 * @param fname 指定文件名
	 * @return 返回文件文本内容
	 */
	static String readFile(String fname) async;

	/*! @brief 创建文件，并写入内容
	 * @param fname 指定文件名
	 * @param txt 指定要写入的字符串
	 */
	static writeFile(String fname, String txt) async;

	/*! @brief 查询指定的文件或目录是否存在
	 * @param path 指定要查询的路径
	 */
	static Boolean exists(String path) async;

	/*! @brief 创建一个目录
	 * @param path 指定要创建的目录名
	 */
	static mkdir(String path) async;

	/*! @brief 删除一个目录
	 * @param path 指定要删除的目录名
	 */
	static rmdir(String path) async;

	/*! @brief 重新命名一个文件
	 * @param from 指定更名的文件
	 * @param to 指定要修改的新文件名
	 */
	static rename(String from, String to) async;

	/*! @brief 查询指定文件的基础信息
	 * @param path 指定查询的文件
	 * @return 返回文件的基础信息
	 */
	static Stat stat(String path) async;
};

/*! @brief 纤程操作对象，此对象不可直接创建，可通过 Function.start 取得*/
class Fiber : Event
{
	/*! 等待纤程结束 */
	join();
	readonly Function func;
};

class coroutine : module
{
	static Fiber start(Function func);
	static Fiber current();
	static sleep(Integer ms);
};

/*! @brief 全局对象，所有脚本均可以访问的基础对象*/
class global : module
{
	/*! @brief 控制台访问对象*/
	static console console;

	/*! @brief 记录普通日志信息，与 console.log 等同
	 * @param fmt 格式化字符串
	 * @param ... 可选参数列表
	 */
	static print(String fmt, ...);

	/*! @brief 运行一个脚本
	 * @param fname 指定要运行的脚本路径
	 */
	static run(String fname);

	/*! @brief 暂停当前纤程指定的时间
	 * @param ms 指定要暂停的时间，以毫秒为单位，缺省为 0，即有空闲立即回恢复运行
	 */
	static sleep(Integer ms = 0);

	/*! @brief 加载一个模块并返回模块对象
	 * @param mod 指定要加载的模块名称
	 */
	static Value require(String mod);

	/*! @brief 强制要求进行垃圾回收*/
	static GC();
};

/*! @brief Function 对象不可创建，仅用于实现对 javascript Function 对象的扩展*/
class Function : object
{
	/*! @brief 启动一个纤程
	 *
	 * 启动纤程不需要特殊创建对象，之需要调用需要在纤程内执行的函数的 start 方法即可：
	 * @code
	 * function func(v1, v2)
	 * {
	 *     if(v1 > v2)
	 *         print(v1);
	 *     else
	 *         print(v2);
	 * }
	 *
	 * var fb = func.start(100, 200);
	 * fb.join();
	 * @endcode
	 *
	 * @param ... 可变参数序列，此序列会在纤程内传递给函数
	 * @return 返回纤程对象
	 */
	static Fiber start(...);
};

